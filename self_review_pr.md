# Pull Requestセルフレビュー

プルリクエストを提出する前に、自分の変更を客観的にレビューします。作業者であるあなた自身がPull Requestの内容を分析し、レビュアーに指摘されそうな問題点や改善案を洗い出します。

重要: レビュアーの時間は貴重です。自分で気づける問題は事前に修正し、レビュアーにはより本質的な指摘に集中してもらいましょう。

セルフレビューの心構え: このセルフレビューには時間がかかってもかまいません。むしろ、徹底的に考え抜いてください。ultrathinkするつもりで、あらゆる角度から自分のコードを検証しましょう。

## 使い方

```
/self_review_pr https://github.com/owner/repo/pull/123
```

Claude Codeのコマンドとして実行され、引数として渡されたPull Request URLは `$ARGUMENTS` 変数で受け取ります。

## 概要

このコマンドは、プルリクエストを提出する前や提出後に自分の変更を客観的にレビューするためのツールです。Pull Requestの作業者であるあなたが一度冷静になって、自分が書いたコードを第三者の視点で見直し、以下の観点から問題点や改善案を検討します。

重要な心構え: このPull Requestはあなたがこれまで作業してきた成果物ですが、その愛着や思い入れを一旦忘れて、初めて見るコードのように冷静に評価してください。自分の成果物だからこそ見えなくなる問題があります。贔屓目なしに、厳しい目で見直すことが質の高いコードにつながります。

注意: このコマンドは分析と提案のみを行います。実際のコード修正は一切行いません。分析結果を見て、どのような対応をするかはユーザー自身が判断してください。あなたの責務は客観的な分析結果を提示することまでです。

- Pull Requestの目的と実装の整合性: タイトル・説明文と実際の変更内容の一致
- コードベースとの整合性: 既存の命名規則、アーキテクチャ、パターンへの準拠
- 変更の影響範囲: 他の部分への影響や考慮漏れの可能性
- CIステータス: ビルド、テスト、リントの状態
- レビュアー視点: レビュアーが指摘しそうなポイント

## 動作原理

### 基本フロー

1. Pull Request情報の取得: GitHub CLIを使用してPull Requestの詳細情報を取得
2. 変更内容の分析: コミット履歴と差分を詳細に確認
3. コードベースの理解: 既存のコード構造とパターンを把握
4. 多角的なレビュー: 様々な観点から問題点を洗い出し
5. 改善提案: 具体的な修正案や対応方法を提示

## 実行手順

### Step 1: Pull Request基本情報の取得

```bash
# Claude Codeのコマンド引数からPull Request URLを取得
PR_URL="$ARGUMENTS"

# gh pr viewでPR情報を取得
PR_INFO=$(gh pr view "$PR_URL" --json number,headRepositoryOwner,headRepository,title,body,author,state,headRefName,baseRefName,changedFiles,additions,deletions,createdAt,commits,statusCheckRollup,mergeable)

# 変数の設定（後のAPI呼び出しで使用）
OWNER=$(echo "$PR_INFO" | jq -r '.headRepositoryOwner.login')
REPO=$(echo "$PR_INFO" | jq -r '.headRepository.name')
PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number')

echo "$PR_INFO"

# Pull Requestの差分を取得（ファイルごとの変更内容）
gh pr diff "$PR_URL"

# 変更されたファイルの一覧
gh pr view "$PR_URL" --json files
```

### Step 2: コミット履歴の分析

```bash
# ベースブランチとヘッドブランチの情報を取得（既に取得済みのPR_INFOから抽出）
BASE_REF=$(echo "$PR_INFO" | jq -r '.baseRefName')
HEAD_REF=$(echo "$PR_INFO" | jq -r '.headRefName')

# ローカルでコミット履歴を確認
git log --oneline "$BASE_REF".."$HEAD_REF"
```

### Step 3: コードベースの理解

作業者であるあなたが以下の点を分析：

- 命名規則: 変数名、関数名、ファイル名のパターン
- アーキテクチャ: ディレクトリ構造、モジュール分割の方針
- コーディングスタイル: インデント、括弧の位置、コメントの書き方
- テストパターン: テストファイルの配置、テストケースの書き方
- 依存関係: 使用しているライブラリ、インポートパターン

### Step 4: レビュー観点の分析

上記のコードベース理解を踏まえて、以下の観点から体系的にレビューを実施します：

#### 1. Pull Requestの目的と実装の整合性

分析項目:
- タイトルが変更内容を正確に表現しているか
- 説明文に記載された目的と実際の変更が一致しているか
- 変更範囲が目的に対して適切か（過不足がないか）
- 要件が完全に満たされているか（部分的な実装になっていないか）

#### 2. コード品質とパターン

確認項目:
- 既存のコーディング規約に従っているか
- 重複コードや冗長な実装がないか（コピペコードは許容しない）
- エラーハンドリングが適切か
- パフォーマンスへの影響
- 整然とした設計になっているか（責任の分離、適切な抽象化）
- 関数の引数や戻り値に適切な型が付けられているか
- 中長期的にメンテナンス可能な設計か（過度に複雑でないか、拡張性はあるか）
- コードベース全体を見て共通化・リファクタリングの機会はないか
- 単一責務の原則が守られているか（1つのクラス・関数が複数の責務を持っていないか）
- 関数が長すぎないか（50-100行でも長い）
- 副作用がある関数から純粋関数を切り出せないか（テストしやすい構造への改善）

#### 3. テストとドキュメント

チェック項目:
- 変更に対するテストが追加されているか（新機能・バグ修正には必須）
- 既存のテストが壊れていないか
- テストが通らないからといってテストをスキップしていないか（絶対に許容しない）
- 正常系だけでなく異常系のテストも書かれているか
- エッジケースや境界値のテストが考慮されているか
- ドキュメントの更新が必要な場合、更新されているか（READMEや設定ファイルなど、修正漏れがないか確認）
- 適切なコメントが書かれているか（何をしているかではなく、なぜ必要なのかを説明）

#### 4. セキュリティとベストプラクティス

レビュー項目:
- セキュリティ上の問題がないか
- ハードコードされた値がないか
- 適切なログ出力がされているか
- 設定値の管理が適切か
- リントエラーを安易にignoreしていないか（本当にどうしようもない理由がある場合を除き許容しない）

重要な原則:
- テストが通らない → テストをスキップするのではなく、コードを修正する
- リントが通らない → ignoreするのではなく、コードを修正する
- どうしても回避が必要な場合は、その理由を明確にコメントで説明する必要がある

#### 5. 視野の広さ

確認項目:
- 今回の変更だけでなく、既存コードとの重複はないか
- 似たような処理が他にあれば、共通化すべきではないか
- 将来的な変更や拡張を考慮した設計になっているか
- 技術的負債を増やしていないか、むしろ減らす機会はないか
- 今回の修正がシステム全体でどういう立ち位置にあるか理解しているか
- 処理の責務はどのレイヤーで担保すべきか（例：リトライ処理はバッチ全体か個別関数か）

### Step 5: 改善提案の生成

作業者として自分の変更を振り返り、以下の形式で具体的な改善案を整理：

## セルフレビュー結果

私が作成したこのPull Requestを客観的に見直した結果：

### 🟢 自分でも良いと思える点
- [自分の実装で納得できている部分]

### 🟡 自分でも改善の余地があると感じる点
- [もう少し工夫できたかもしれない部分]
- 改善案: [どのように改善すべきか]

### 🔴 レビュー前に自分で修正すべき点
- [明らかに問題がある部分]
- 修正方法: [具体的な修正内容]